// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: query.sql

package db

import (
	"context"
	"time"
)

const addExpense = `-- name: AddExpense :one

INSERT INTO budget_schema.expense(
	username,
	shop_name,
	category,
	price,
	expense_date
) VALUES ($1, $2, $3, $4, $5) RETURNING id
`

type AddExpenseParams struct {
	Username    string    `json:"username"`
	ShopName    string    `json:"shop_name"`
	Category    string    `json:"category"`
	Price       float64   `json:"price"`
	ExpenseDate time.Time `json:"expense_date"`
}

//
// Expenses
//
func (q *Queries) AddExpense(ctx context.Context, arg AddExpenseParams) (int32, error) {
	row := q.db.QueryRow(ctx, addExpense,
		arg.Username,
		arg.ShopName,
		arg.Category,
		arg.Price,
		arg.ExpenseDate,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const addSalary = `-- name: AddSalary :one

INSERT INTO budget_schema.salary(username, salary, store_date)
	VALUES($1, $2, $3) RETURNING id
`

type AddSalaryParams struct {
	Username  string    `json:"username"`
	Salary    float64   `json:"salary"`
	StoreDate time.Time `json:"store_date"`
}

//
// Salaries
//
func (q *Queries) AddSalary(ctx context.Context, arg AddSalaryParams) (int32, error) {
	row := q.db.QueryRow(ctx, addSalary, arg.Username, arg.Salary, arg.StoreDate)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteExpenseByID = `-- name: DeleteExpenseByID :one
DELETE FROM budget_schema.expense
	WHERE id = $1 AND username = $2
	RETURNING id, username, shop_name, category, price, expense_date
`

type DeleteExpenseByIDParams struct {
	ID       int32  `json:"id"`
	Username string `json:"username"`
}

func (q *Queries) DeleteExpenseByID(ctx context.Context, arg DeleteExpenseByIDParams) (*BudgetSchemaExpense, error) {
	row := q.db.QueryRow(ctx, deleteExpenseByID, arg.ID, arg.Username)
	var i BudgetSchemaExpense
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.ShopName,
		&i.Category,
		&i.Price,
		&i.ExpenseDate,
	)
	return &i, err
}

const deleteSalaryByID = `-- name: DeleteSalaryByID :one
DELETE FROM budget_schema.salary
	WHERE id = $1 AND username = $2
	RETURNING id, username, salary, store_date
`

type DeleteSalaryByIDParams struct {
	ID       int32  `json:"id"`
	Username string `json:"username"`
}

func (q *Queries) DeleteSalaryByID(ctx context.Context, arg DeleteSalaryByIDParams) (*BudgetSchemaSalary, error) {
	row := q.db.QueryRow(ctx, deleteSalaryByID, arg.ID, arg.Username)
	var i BudgetSchemaSalary
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Salary,
		&i.StoreDate,
	)
	return &i, err
}

const getAggrExpensesByTimespan = `-- name: GetAggrExpensesByTimespan :many
SELECT username, date_trunc('month', expense_date)::date AS months, SUM(price)::float AS expenses_sum
	FROM budget_schema.expense
	WHERE expense_date BETWEEN $1::date
		AND $2::date + interval '1 month - 1 day'
	GROUP BY username, months, shop_name
	ORDER BY months, username
`

type GetAggrExpensesByTimespanParams struct {
	StartTime time.Time `json:"start_time"`
	EndTime   time.Time `json:"end_time"`
}

type GetAggrExpensesByTimespanRow struct {
	Username    string    `json:"username"`
	Months      time.Time `json:"months"`
	ExpensesSum float64   `json:"expenses_sum"`
}

func (q *Queries) GetAggrExpensesByTimespan(ctx context.Context, arg GetAggrExpensesByTimespanParams) ([]*GetAggrExpensesByTimespanRow, error) {
	rows, err := q.db.Query(ctx, getAggrExpensesByTimespan, arg.StartTime, arg.EndTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAggrExpensesByTimespanRow
	for rows.Next() {
		var i GetAggrExpensesByTimespanRow
		if err := rows.Scan(&i.Username, &i.Months, &i.ExpensesSum); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpensesByTimespan = `-- name: GetExpensesByTimespan :many
SELECT id, username, expense_date, shop_name, price FROM budget_schema.expense
	WHERE expense_date BETWEEN $1::date
		AND $2::date + interval '1 month - 1 day'
	ORDER BY username, expense_date, shop_name, price
`

type GetExpensesByTimespanParams struct {
	StartTime time.Time `json:"start_time"`
	EndTime   time.Time `json:"end_time"`
}

type GetExpensesByTimespanRow struct {
	ID          int32     `json:"id"`
	Username    string    `json:"username"`
	ExpenseDate time.Time `json:"expense_date"`
	ShopName    string    `json:"shop_name"`
	Price       float64   `json:"price"`
}

func (q *Queries) GetExpensesByTimespan(ctx context.Context, arg GetExpensesByTimespanParams) ([]*GetExpensesByTimespanRow, error) {
	rows, err := q.db.Query(ctx, getExpensesByTimespan, arg.StartTime, arg.EndTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetExpensesByTimespanRow
	for rows.Next() {
		var i GetExpensesByTimespanRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.ExpenseDate,
			&i.ShopName,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSalariesByTimespan = `-- name: GetSalariesByTimespan :many
SELECT username, salary, date_trunc('month', store_date)::date AS months FROM budget_schema.salary
	WHERE store_date BETWEEN date_trunc('month', $1::date)::date
		AND date_trunc('month', $2::date)::date + interval '1 month - 1 day'
	GROUP BY username, months, salary
	ORDER BY username, months
`

type GetSalariesByTimespanParams struct {
	StartTime time.Time `json:"start_time"`
	EndTime   time.Time `json:"end_time"`
}

type GetSalariesByTimespanRow struct {
	Username string    `json:"username"`
	Salary   float64   `json:"salary"`
	Months   time.Time `json:"months"`
}

func (q *Queries) GetSalariesByTimespan(ctx context.Context, arg GetSalariesByTimespanParams) ([]*GetSalariesByTimespanRow, error) {
	rows, err := q.db.Query(ctx, getSalariesByTimespan, arg.StartTime, arg.EndTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetSalariesByTimespanRow
	for rows.Next() {
		var i GetSalariesByTimespanRow
		if err := rows.Scan(&i.Username, &i.Salary, &i.Months); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSalaryByMonth = `-- name: GetUserSalaryByMonth :one
SELECT salary FROM budget_schema.salary
	WHERE username = $1
	AND store_date = date_trunc('month', $2::date)
`

type GetUserSalaryByMonthParams struct {
	Username string    `json:"username"`
	Month    time.Time `json:"month"`
}

func (q *Queries) GetUserSalaryByMonth(ctx context.Context, arg GetUserSalaryByMonthParams) (float64, error) {
	row := q.db.QueryRow(ctx, getUserSalaryByMonth, arg.Username, arg.Month)
	var salary float64
	err := row.Scan(&salary)
	return salary, err
}

const statisticsAggrByTimespan = `-- name: StatisticsAggrByTimespan :many

SELECT b.username, date_trunc('month', b.expense_date)::date AS event_date, SUM(price)::float AS expenses_sum, s.salary, 0.0::float AS owes
		FROM budget_schema.expense AS b
        JOIN budget_schema.salary AS s ON b.username = s.username
		AND date_trunc('month', s.store_date) = date_trunc('month', b.expense_date)
	WHERE b.expense_date BETWEEN date_trunc('month', $1::date)::date
		AND date_trunc('month', $2::date)::date + interval '1 month - 1 day'
		OR s.store_date BETWEEN date_trunc('month', $1::date)::date
		AND date_trunc('month', $2::date)::date + interval '1 month - 1 day'
	GROUP BY b.username, date_trunc('month', b.expense_date), s.salary
	ORDER BY b.username, date_trunc('month', b.expense_date), expenses_sum
`

type StatisticsAggrByTimespanParams struct {
	StartTime time.Time `json:"start_time"`
	EndTime   time.Time `json:"end_time"`
}

type StatisticsAggrByTimespanRow struct {
	Username    string    `json:"username"`
	EventDate   time.Time `json:"event_date"`
	ExpensesSum float64   `json:"expenses_sum"`
	Salary      float64   `json:"salary"`
	Owes        float64   `json:"owes"`
}

//
// Miscellaneous
//
func (q *Queries) StatisticsAggrByTimespan(ctx context.Context, arg StatisticsAggrByTimespanParams) ([]*StatisticsAggrByTimespanRow, error) {
	rows, err := q.db.Query(ctx, statisticsAggrByTimespan, arg.StartTime, arg.EndTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*StatisticsAggrByTimespanRow
	for rows.Next() {
		var i StatisticsAggrByTimespanRow
		if err := rows.Scan(
			&i.Username,
			&i.EventDate,
			&i.ExpensesSum,
			&i.Salary,
			&i.Owes,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
